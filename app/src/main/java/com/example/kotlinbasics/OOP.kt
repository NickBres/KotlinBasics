package com.example.kotlinbasics

import kotlin.properties.Delegates

fun main(){
    var iphone = Phone("iOs","Apple","iPhone 15")
    var samsung = Phone("Android", "Samsung","Galaxy s24", 1000)
    iphone.makeACall()
    samsung.makeACall()

    // Data classes
    val user1 = User(1,"John")
    println(user1) // prints User(id=1, name=John)
    user1.name = "John Doe"
    println(user1) // prints User(id=1, name=John Doe)
    // copy method
    // can change the values of properties while copying by passing them as arguments
    val user2 = user1.copy(id = 2)
    println(user2) // prints User(id=2, name=John Doe)
    // comparing data classes
    println(user1 == user2) // prints false because id is different
    // get properties using componentN() method
    println(user1.component1()) // prints 1
    println(user1.component2()) // prints John Doe
    // getting properties using destructuring
    val (id,name) = user1 // creates two variables id and name and assigns them the values of user1

    // Inheritance
    val animal = Animal("Animal")
    val dog = Dog("Dog")
    animal.makeSound() // prints Animal is making a sound
    dog.makeSound() // prints Dog is making a sound

    // Type casting
    val animal2: Animal = Dog("Dog")
    // animal2.bark() // error because animal2 is of type Animal
    // to call bark() we need to type cast animal2 to Dog
    // there are two ways to type cast
    // 1. using as keyword (unsafe) - throws ClassCastException if casting is not possible
    (animal2 as Dog).bark()
    // 2. as? keyword (safe) - returns null if casting is not possible
    (animal2 as? Dog)?.bark()
    // 3. using is keyword (safe)
    if(animal2 is Dog){
        animal2.bark()
    }

}

// Class syntax
// class ClassName(args) { ... } - () is optional it is used to pass arguments to the primary constructor
class Phone(osName: String = "No os",brand: String = "No brand",model: String = ""){
    // Member Variables/Properties
    // use lateinit to initialize properties later and not make them nullable
    lateinit var osName: String
    lateinit var brand: String
    lateinit var model: String
    // getter and setter are generated by kotlin automatically for properties
    // custom getter and setter need to be written below the property
    // using field and value syntax to avoid stack overflow because of recursion
    var price: Int = 0
        get() = field // its default getter
        set(value) {
            field = if(value > 0) value else throw IllegalArgumentException("Price can't be negative")
        }
    // you can also assign private setter and getter to a property (getter and setter are public by default)
    // getter visibility must be same as property visibility
    var color: String = "Black"
        private set
        get() = field



    // Secondary Constructor
    // Syntax: constructor(args) : this(args) { ... } - this calls the primary constructor its optional
    constructor(osName: String = "No os",brand: String = "No brand",model: String = "",price: Int = 0) : this(osName,brand,model) {
        this.price = price
        println("Phone $model of brand $brand with $osName os and price $price has been created")
    }

    // Initializer block to initialize properties
    init {
        this.osName = osName
        this.brand = brand
        this.model = model
        println("Phone $model of brand $brand with $osName os has been created")
    }

    // getter and setter


    // Member functions/Methods
    fun makeACall(){
        println("$model is calling")
    }
}

// Data classes
// are used to hold data
// are immutable
// can't be abstract, sealed or inner
// must have at least one parameter in primary constructor
data class User(val id: Long, var name: String)

// Inheritance
// all classes are final (not inheritable) by default. to make a class inheritable, use open keyword
open class Animal(val name: String){
    // properties and methods of a class are final by default. to make them overridable, use open keyword
    open fun makeSound(){
        println("Animal is making sound")
    }
}

class Dog(name: String) : Animal(name){
    // to override a property or method, use override keyword
    override fun makeSound() {
        println("Dog is barking")
    }
    fun bark(){
        println("Dog is barking")
    }
}

// Interfaces
interface Drivable{
    fun drive()
    fun brake(){
        println("Stopping")
    }
}

interface Electric{
    val batteryLife: Double

    fun recharge(){
        println("Recharging")
    }
}

// Implementing interfaces
class Car(override val batteryLife: Double) : Drivable, Electric{
    override fun drive() {
        println("Driving")
    }

    override fun brake() {
        super.brake()
        println("Braking")
    }
}

// Abstract classes
abstract class Mammal(val name: String){
    abstract val lifeSpan: Int
    abstract fun makeSound() // abstract methods don't have a body
    fun eat(){ // non-abstract methods can be defined also
        println("Eating")
    }
}

class Human(name: String, override val lifeSpan: Int) : Mammal(name){
    override fun makeSound() {
        println("Talking")
    }
}